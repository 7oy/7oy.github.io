"use strict";

let main={
address:"https://script.google.com/macros/s/AKfycbyq-zVq4JyIK0sXLV2hil82smssD61Cy3EeFVUUV1DxwUg2wyeIjSnjXXiQ0kYlVII/exec", //адрес макроса выдачи/записи данных
text:null,//переменная в которой хранится присланный кодированный текст
load(){//инициализация модуля ошибок
	$.bind_all(main);//биндим объект, чтобы в функциях можно было использовать "this"
	$.d.head.after(main.bar=$.d.createElement("bar"));//создаем контейнер для индикации загрузки и вставляем его в head
	//$.mod(main.bar,1,"c");//назначаем ему стиль
	let s=window.location.search;//объект с данными о текущем адресе страницы
	if(s.length==0)$.event(1,$.b,"click",main.protect_encode);//обработчик для клика на верхней правой части экрана, навешивается для перехода на страницу на которой создаем запись
	else if(s.length>100) fail.red("Превышен размер переданных данных!");
	else main.window_decode(s);//выполняется для входа на страницу на которой получаем и дешифруем запись
},
class(a=$.all()){//проходит по переданным элементам и вешает на них указанные классы
	let c={//объект с классами
			INPUT:"t",
			T:"t",
		};
	for(let v of a)v.tagName in c&&$.mod(v,1,...c[v.tagName]);
},
window_decode(text){//функция запроса сообщения и его декодировки
	let find=text.slice(1,5),//отпиливаем от адреса 4 символа, начиная с 1 ("0" это знак "?"), получаем идентификатор записи в базе
		m=this;
	$.ajax(m.address,{find:find})//отправляем запрос(идентификатор записи) по адресу базы данных
	.then(response=>{
		if("result" in response){//если есть положительный ответ
			m.text=m.a[1].innerText=response.result;//записываем полученный результат в текстовое поле
			m.resize_text();//корректируем размер текстового поля под текст
		}
		else if("error" in response)throw new Error(response.error);//если база данных отправила ошибку
	})
	.catch(error=>{//обработка ошибок произошедших на сервере
		fail.red(error);
	})
	.finally(_=>m.wait());//убираем индикатор ожидания
	$.b.i=0;//указываем, какая форма будет в теле страницы(0 - декодирование, 1 - кодирование)
	m.layout();//вставка макета формы
	m.wait(1);//показываем индикатор ожидания, снимется асинхронно, когда придёт ответ от сервера
},
event_encode(){//функция, которая висит на кнопке "кодировать", кодирует и отправляет сообщения на сервер
	let m=this,
		password=m.a[0].value,//пароль введённый в форму
		text=m.a[1].innerText,//текст введённый в форму для кодирования и сохранения на сервер
		message;//зашифрованный текст который будет отправлен на сервер
	if((password.length==0)||(text.length==0)){m.red(m.a);fail.red("Необходимые данные для отправки данных отсутствуют!");}//проверка на наличие дынных в текстовом поле и в поле пароля
	else{
		message=$.encrypt(password,text);//кодируем текст
		m.wait(1);//показываем индикатор ожидания
		$.ajax(m.address,{set:message})//отправка данных на сервер
		.then(response=>{
			if("id" in response)m.show_link(response.id);//если в ответе есть "id", то запись выполнена успешно
			else if("error" in response)throw new Error(response.error);//если в ответе есть "error", то возникли ошибки на стороне сервера
		})
		.catch(error=>{//обработка ошибок произошедших на стороне сервера
			fail.red(error);
			m.wait();//убираем индикатор ожидания
		});
	};
},
event_decode(){//при нажатии по кнопке декодирует сообщение
	let m=this,
		a=m.a,
		text;
	if((event.type=="keyup")&&(event.key!="Enter")) return;//если функция вызвана отпусканием кнопки и это не "Enter" то выходим из функции 
	text=(event.ctrlKey)?a[1].innerText:m.text; /*если нажат "Ctrl", то расшифровываем введённый текст, иначе берем раннее полученные данные с сервера(сделано, чтобы можно было расшифровывать данные не только с сервера)*/
	if((a[0].value.length==0)||(m.text==null)){m.red(m.a);fail.red("Необходимые данные для расшифровки отсутствуют!");}
	else{
		text=$.decrypt(a[0].value,text);//декодируем текст с помощь введённого пароля
		a[1].innerText=text;//(или this.text), расшифровка зашифрованного текста
		m.resize_text();
	};
},
protect_encode(){//обработчик клика для вставки формы создания записи, срабатывает если кликнуть мышью в верхнем левом углу, также ширина и длина блока страницы должна быть больше 300 
	let property=event.target.getBoundingClientRect(),//метод предоставляющий информацию о размере элемента и его положении относительно области просмотра
		width=property.width,//ширина объекта на котором сработало событие
		height=property.height,//длинна объекта на котором сработало событие
		x=event.offsetX,//координаты клика мыши от верхнего левого угла объекта на котором сработало событие
		y=event.offsetY,
		m=this;
	if((width>300)&&(height>300)&&(x<300)&&(y<300)){//проверка на попадание в координаты
		$.event(0,$.b,"click",m.protect_encode);//удаляем обработчик на вставку формы создания записи
		$.b.i=1;//указываем, какая форма будет в теле страницы(0 - декодирование, 1 - кодирование)
		m.layout();//вставка макета формы
	};
},
show_link(link){//выводит ссылку для сообщения
	let l=window.location,//информация о текущем расположении документа
		m=this,
		actual=l.origin[0]=="h"?l.origin.slice(8):l.href+"?"+link;//получаем ссылку на сохранённую информацию
	//первая буква "h" если страница находится в интернете то отпиливаем "htpps://" и выводим ссылку
	//и второй вариаент если страница находится в локальном месте
	m.wait();//выключаем индикатор ожидания
	m.layout(0);
	$.b.innerHTML="<k>Скопировать ссылку";//вставка контейнера с адресом записи в тело страницы
	m.class();
	$.mod($.b,1,"link");
	$.event(1,$.d.querySelector("k"),"click",_=>navigator.clipboard.writeText(actual).catch(e=>fail.red(e)));//копировать в буфер при клике по кнопке(ссылку на запрос информации)
},
layout(i=1){//макет на основе которого создается формы
	let b='<input type="password"placeholder="Пароль"><t i="Текст"contentEditable="plaintext-only"spellcheck="false"></t><k>',//поле для ввода пароля и кнопка
		m=this,
		e=(t,o)=>{//уменьшаем количество кода, t-(a/r) вешаем/стираем событие, o-объект на который вешаем событие
			let a=[
					[t,o[1],"input",m.resize_text],//вешаем обработчик на textarea для автоматической подстройки размера
					[t,window,"resize",m.resize_text],//подстраивает текстовое поле под изменение размера экрана
				];
			a.push(...$.b.i?
					[[t,o[2],"click",m.event_encode]]//вешаем обработчик на кнопку для кодирования и отправки записи на сервер
					:[[t,o[2],"click",m.event_decode],//обработчик клика по кнопке декодировать
					[t,o[0],"keyup",m.event_decode]]//обработчик отпускания физической кнопки "Enter" в поле ввода пароля
			);
			$.event(...a);
		};
	if(i){
		$.b.innerHTML=b;//вставка содержимого в body
		m.a=$.all();//создаём ссылки на элементы
			//0: input - ссылка на поле с паролем
			//1: t	 - ссылка на текстовое поле
			//2: k	 - ссылка на кнопку
		m.a[2].innerText=["Декодировать","Кодировать"][$.b.i];//обзываем кнопку формы
		m.class(m.a);
		e(1,m.a);//вешаем события
	}else e(0,m.a);//снимаем события
},
wait(i=0){//показывает/скрывает индикатор ожидания(бар/линию загрузки)
	$.mod(this.bar,i,"s");
},
red(x){//функция которая при вводе неправильного пароля, окрашивает на время рамку поля ввода пароля красным цветом
	//x - объекты на который вешаем ошибку
	if($.mod(x[0],2,"e"))return;//если класс "e" уже висит на заданном поле ввода, то выходим из функции
	let f=(x,y)=>{for(let i=2;i--;)$.mod(x[i],y,"e")};//функция проходит по полям ввода пароля и текста и вешает/снимает с/на них класс
	f(x,1);
	setTimeout(_=>f(x,0),500);//ставим таймер на последующее удаление класса "e" с объекта
},
resize_text(){//изменение длины текстового поля, для подстройки под размер его наполнения
	let t=this.a[1];//переопределение ссылки на текстовое поле, для удобства
	t.style.height="auto";//измеряем полосу прокрутки
	if(t.scrollHeight>=60)t.style.height=3+(t.scrollHeight)+"px";//если в элементе больше одной строки, то увеличиваем размер элемента
	else t.removeAttribute("style");//иначе удаляем свойство, иначе уплывает нижняя граница(1px <-> 2px)
},
};

let $={//Объект, упрощающий жизнь
d:document,
all:_=>$.b.querySelectorAll("*"),
mod(e,d,...a){e.classList[["remove","add","contains"][d]](...a)},//работа с классом на элементе "dom`s"
	//e-элемент с которым работаем, d-что будем делать с этим элементом, a-собственно "класс"(может принимать несколько классов в виде массива или строки, передавать с оператором: "...")
load(){
	let w=window;
	$.b=$.d.body;
	w.s=_=>String.fromCharCode(_);//возвращает символ, получая его код
	w.int=_=>parseInt(_,16);//анализирует строковый аргумент и возвращает целое число по 16-ой системе счисления
},
event(...array){//навешивает/удаляет обработчик на объект/массив объектов
	let a=typeof array[0]==="number"?[array]:array;//если строка запихиваем её в массив
	for(let v of a)v[1][["remove","add"][v[0]]+"EventListener"](v[2],v[3]);//навешиваем/удаляем обработчик на объект
	//первым делом из объекта выбираем "add" или "remove", и плюсуем это слово к "EventListener", получаем название метода
	//затем вызываем полученный метод(с именем строкой) в виде свойства на элементе на котором хочем вызвать этот метод
	//и в скобках передаём параметры данного метода
},
bind_all(obj){for(let method in obj)if(typeof obj[method]=="function")obj[method]=obj[method].bind(obj)},//задаёт функциям ссылку на родительский объект
int_str16(a){//преобразует массив 8 битных цифр в строку из цифр в 16-й системе
	let r="";
	for(let v of a)r+=v.toString(16).padStart(2,"0");
	return r;
},
async ajax(url,obj=0){//AJAX модуль
	let controller=new AbortController(),//объект который позволяет сбросить запрос
		signal=controller.signal;
	setTimeout(()=>controller.abort(),20000);//таймер на сброс запроса
	let options={//определяем объект с опциями запроса
			method:"post",
			headers:{"Content-Type":"text/plain;charset=utf-8"},
			cache:"no-cache",
			body:JSON.stringify(obj),
			signal
		},
		response=await fetch(url,options),
		text,//тело ответа
		data;//обработанное тело ответа
	if(!response.ok) throw new Error (response.status+" "+response.statusText);//проверка на ошибки
	text=await response.text();//получаем тело ответа
	data=JSON.parse(text);//парсим тело ответа в объект
	if(data.alert) throw new Error(data.error);//проверяем есть ли проблемы на стороне сервера
	return data;
},
ingot(password,length){//функция заготовки, создает на основе password и length хеш заданной длины
	//length это количество хэш строк, которых нужно чтобы накрыть текст который нужно закодировать(+1, учитываем ключ)
	let n=length*8,//количество перестановочных шаблонов, 8 это 128/16, где 128 длина хэша(количество символов в строке хэша или 64 байта), 16 - длина перестановочного шаблона
		hash=[],//переменная для хранения крайнего значения хэша
		array=[],//переменная для хранения массива перестановочных шаблонов
		mask_1=[],//первая маска, служит основой
		mask_2=[],//вторая маска которая будет накладываться на первую со смещением в 2 байта
		sha=(p,h)=>$.sha_3(p+$.int_str16(h)),//функция необходимая для уменьшения размера суммирует строку и массив(предварительно преобразовав его в строку) и получает хэш от результирующей строку
		permutation=(hash,password)=>{//функция для создания одного перестановочного шаблона из хэш значения
			let template=[],//перестановочный шаблон
				t=[];//хэш строка в виде массива из цифр размером 4 бит
			while(template.length<16){//цикл будет продолжаться пока размер шаблона не станет равным 16
				for(let v of hash=sha(password,hash))t.push(v/16|0,v%+16);//разбиваем массив из 8 битных цифр на массив из 4 битных цифр
				//см. выше вычисляем хэш на основе шаблона и предыдущего использованного хэша
				for(let v of t)!template.includes(v)&&template.push(v);
			};//проходим по длине хэша,вставляем в шаблон уникальные цифры из хэш массива
			return[template,hash];//возвращаем перестановочный шаблон и крайний использованный хэш
		};
		//создаем массив перестановочных шаблонов необходимой длины 
	for(let i=0;i<n;i++)[array[i],//записываем в массив один перестановочный шаблон
		hash]=permutation(hash,password);//получаем новый хэш после каждой итерации
	for(let v of [mask_1,mask_2])for(let i=0;i<length;i++)v.push(...hash=sha(password,hash));//рассчитываем первую маску и вторую маску
	for(let i=1,l=n*8;i<l;i++)mask_1[i]^=mask_2[i-1];//суммируем маски(вторая маска накладывается со смещением на 2 байта)
	mask_1[0]^=mask_2[n*8-1];//суммируем 0 цифру 1 маски, с крайней цифрой 2 маски
	return [array,mask_1];//возвращает массив перестановочных шаблонов, маску которые будут накладываться на текст
},
encrypt(password,text){//функция шифровки текста, путем накладывания на него маски
	text.normalize();//приводит буквы к нормальному виду
	let arr_text=new TextEncoder().encode(text),//new TextEncoder().encode(text) - переводит символы в буквенные коды(utf-8), а именно 8-битный массив
		l_t=arr_text.length,//длинна массива цифр получившегося из текста
		n=Math.ceil((l_t)/64),//округление до большего целого,считаем сколько нужно хэшей чтобы накрыть массив цифр(символов)
		[array,//массив перестановочных шаблонов
		mask]//кодирующая маска на основе пароля в виде массива 8 битных цифр
		=$.ingot(password,n+1),//получаем массив перестановочных шаблонов и маску на основе пароля(+1, учитываем то, что к тексту будет добавлен "ключ")
		mask_t=[],//массив хэшей на основе текста
		r,//это массив цифр, составленный из массивов "дозаполнения" и ключа(который нужен для того чтобы при изменении даже одного символа в тексте, полностью менялся результат шифрования)
		str_16,//строка зашифрованного текста перед наложением перестановочного шаблона
		mix="";//собственно результат, а именно зашифрованный текст после наложения  перестановочного шаблона
	for(let i=0,key=text;i<n+2;i++)mask_t.push(...key=$.sha_3(key));//заполняем массив 8 битных цифр, полученными на основе ключа(первым ключом является сам текст), хэшами
	while(mask_t[l_t+127]==arr_text[l_t-1]){//проверяем на совпадение символов, крайнего перед вырезаемой строкой из хэша и крайнего символа из текста
		//где l_t+127 это l_t+64*2-1, потому что mask_t размером на 2 хэша больше и -1, потому что берётся длина length от arr_text
		mask_t.splice(0,64);//если всё-таки совпали, то удаляем первый хэш(64 цифры) и смещаем по позициям остальные хэши
		mask_t.push(...$.sha_3(mask_t.slice(-64)));//генерируем крайний хэш на основе крайнего же хэша
	};
	for(let i=0,l=n*64;i<l;i++)mask[i]^=arr_text[i]^mask_t[i+64];//накладываем маску( и маску на основе текста) на текст
	r=[...mask_t.slice(l_t-n*64),...mask_t.slice(0,64)];//слаживаем массивы "дозаполнения" и ключа(который нужен для того чтобы при изменении даже одного символа в тексте, полностью менялся результат шифрования)
	for(let i=0,l=r.length;i<l;i++)mask[i+l_t]^=r[i];//накладываем на зашифрованный текст, дозаполняющий массив и ключ
	str_16=$.int_str16(mask);//преобразуем массив цифр в строку из цифр в 16 системе
	for(let i=0,l=++n*8;i<l;i++)for(let y=0;y<16;y++)mix+=str_16[i*16+array[i][y]];//переставляем символы в строке согласно шаблону(++n*8 это array.length)
	return mix;//возвращаем зашифрованный текст
},
decrypt(password,text){//функция дешифровки зашифрованного текста, путем накладывания на него маски
	let n=Math.ceil((text.length)/128),//округление до большего целого, рассчитываем длину хэш строки
		[array,//массив перестановочных шаблонов
		mask]//кодирующая маска на основе пароля в виде массива 8 битных цифр
		=$.ingot(password,n),//получаем массив перестановочных шаблонов и маску на основе пароля
		arr4_text=[],//массив 4 битных цифр, полученных после применяя перестановочных шаблонов на зашифрованный текст arr4_text
		arr_text=[],//массив текста в виде 8 битных цифр, основная переменная с которой будем работать
		mask_t=[],//массив 8 битных цифр, полученных из хэшей сгенерированных на основе ключа(где ключ, это хэш полученный на основе зашифрованного текста)
		coincidet=(a,b)=>{for(let i=64;i--;)if(a[i]!=b[i])return i;};//функция сравнивает два массива из 8 битных цифр и возвращает индекс элемента с которого элементы в этих массивах будут разными(сравнивает с конца массивов)
	//и нужна чтобы убрать добавочные символы, который нужны были чтобы количество представлений символов текста, было кратным 64
	for(let i=0;i<array.length;i++)for(let y=0;y<16;y++)arr4_text[i*16+array[i][y]]=text[i*16+y];//проходим по массиву перестановочных шаблонов
		//собираем из 16 символьных строк, 16 символьный массив но уже в правильном порядке символов и объединяем их в один массив (1 символ в 16 системе,- 4 бита)
	for(let i=1,l=arr4_text.length;i<l;i+=2)arr_text.push(int(arr4_text[i-1]+arr4_text[i]));//превращаем массив символов(1 символ в 16 системе,- 4 бита) в массив 8 битных цифр
	for(let i=0,l=arr_text.length;i<l;i++)arr_text[i]^=mask[i];//накладываем маску из парольных хэшей на зашифрованный текст
	for(let i=0,key=arr_text.slice(-64);i<n;i++)mask_t.push(...key=$.sha_3(key));//заполняем массив 8 битных цифр, полученными на основе ключа, хэшами
	//arr_text.slice(-64);//отрезаем массив цифр ключа от зашифрованного текста
	//где key ключ для генерации массива хэшей, отрезается из текста на который наложены эти самые хэши(данная маска применяется для того, чтобы при изменении любого символа, полностью менялся результат кодирования текста)
	for(let i=0,l=arr_text.length;i<l;i++)arr_text[i]^=mask_t[i];//накладываем маску на основе ключа из зашифрованного текста на зашифрованный текст
	return new TextDecoder().decode(new Uint8Array(arr_text.slice(0,-127+coincidet(arr_text.slice(-128,-64),mask_t.slice(-64)))));//расшифрованный текст
	//см. выше, получаем смещение чтобы отрезать от основного текста добавочные символы затем, массив 8 битных цифр превращаем в Uint8Array, а затем превращаем Uint8Array в текст
},
sha_3(str){//хэш функция SHA3_512
	if(typeof str!=="string")str=$.int_str16(str);
	let r=576,
		c=1024,
		l=c/2,
		msg=new TextEncoder().encode(str).reduce((prev,curr)=>prev+s(curr),""),
		state=[[],[],[],[],[]];
	for(let x=0;x<5;x++)for(let y=0;y<5;y++)state[x][y]=0n;
	let q=(r/8)-msg.length%(r/8);
	if(q==1)msg+=s(0x86);
	else{
		msg+=s(0x06);
		msg+=s(0x00).repeat(q-2);
		msg+=s(0x80);
	};
	let w=64,
	blocksize=r/w*8,
	keccak_f_1600=a=>{
		let nRounds=24,
			RC=[
			0x0000000000000001n,0x0000000000008082n,0x800000000000808an,
			0x8000000080008000n,0x000000000000808bn,0x0000000080000001n,
			0x8000000080008081n,0x8000000000008009n,0x000000000000008an,
			0x0000000000000088n,0x0000000080008009n,0x000000008000000an,
			0x000000008000808bn,0x800000000000008bn,0x8000000000008089n,
			0x8000000000008003n,0x8000000000008002n,0x8000000000000080n,
			0x000000000000800an,0x800000008000000an,0x8000000080008081n,
			0x8000000000008080n,0x0000000080000001n,0x8000000080008008n,
			],
			ROT=(a,d)=>BigInt.asUintN(64,a<<BigInt(d)|a>>BigInt(64-d));
		for(let r=0;r<nRounds;r++){
			let C=[],D =[];
			for(let x=0;x<5;x++){
				C[x]=a[x][0];
				for(let y=1;y<5;y++)C[x]=C[x]^a[x][y];
			};
			for(let x=0;x<5;x++){
				D[x]=C[(x+4)%5]^ROT(C[(x+1)%5],1);
				for(let y=0;y<5;y++)a[x][y]=a[x][y]^D[x];
			};
			let [x,y]=[1,0],
				current=a[x][y];
			for(let t=0;t<24;t++){
				let [X,Y]=[y,(2*x+3*y)%5],
					tmp=a[X][Y];
				a[X][Y]=ROT(current,((t+1)*(t+2)/2)%+64);
				current=tmp;
				[x,y]=[X,Y];
			};
			for(let y=0;y<5;y++){
				let C=[];
				for(let x=0;x<5;x++)C[x]=a[x][y];
				for(let x=0;x<5;x++)a[x][y]=(C[x]^((~C[(x+1)%5])&C[(x+2)%5]));
			};
			a[0][0]=(a[0][0]^RC[r]);
		};
	};
	let transpose=array=>array.map((row,r)=>array.map(col=>col[r]));
	for(let i=0;i<msg.length;i+=blocksize){
		for(let j=0;j<r/w;j++){
			let i64=(BigInt(msg.charCodeAt(i+j*8+0))<<0n)+(BigInt(msg.charCodeAt(i+j*8+1))<<8n)+(BigInt(msg.charCodeAt(i+j*8+2))<<16n)+(BigInt(msg.charCodeAt(i+j*8+3))<<24n)+(BigInt(msg.charCodeAt(i+j*8+4))<<32n)+(BigInt(msg.charCodeAt(i+j*8+5))<<40n)+(BigInt(msg.charCodeAt(i+j*8+6))<<48n)+(BigInt(msg.charCodeAt(i+j*8+7))<<56n),
				x=j%5,
				y=Math.floor(j/5);
			state[x][y]=state[x][y]^i64;
		};
		keccak_f_1600(state);
	};
	let g=transpose(state);
	return new Uint8Array((new BigUint64Array(g.flat().slice(0,8))).buffer);
},
};

let fail={//Модуль ошибок
load(){//инициализация модуля ошибок
	$.bind_all(fail);
	$.d.head.after(fail.alarm=$.d.createElement("alarm"));//создаем контейнер для сообщений и вставляем его в head
	$.event(1,fail.alarm,"click",fail.delete);//вешаем обработчик на кнопки закрытия сообщений
},
red(text){console.error(text);this.timer(this.paste(text,"red"));},//ошибка
green(text){console.info(text);this.timer(this.paste(text,"green"));},//информационное сообщение
orange(text){console.warn(text);this.paste(text,"orange");},//важное сообщение
timer(node){//ставит таймер на удаление сообщения
	let timer=setInterval(()=>{
		if(!node)clearInterval(timer);
		else if(!+window.getComputedStyle(this.alarm).order){
/*
	Если курсор не наведен, то удаляет сообщение;
	считывает свойство CSS(order), которое меняется от наведения курсора,
	"+" превращает символ в число.
*/
		node.remove();
		clearInterval(timer);
	  }
	},5000);
},
delete(){//удаляет сообщение по клику
	if(event.target.tagName=="X")event.target.parentNode.remove();
},
paste(text,color){
	let a=$.d.createElement(color);
	a.innerHTML=text+"<x>";//текст + кнопка закрытия сообщения
	$.mod(a,1,...["r",color]);
	return this.alarm.appendChild(a);//вставляем сообщение в контейнер, и возвращаем ссылку на объект чтобы по таймеру объект(сообщение) был удалён
}
};

(()=>{//функция для автоматического запуска модулей
	let run=()=>{
		$.event(0,document,"DOMContentLoaded",run);
		let date=[
			$.load,
			fail.load,
			main.load,
			];
			Promise.all(date.map(Function=>Function()))//промисс параллельного выполнения, метод map проходит по принимаемому массиву и выполняет указанную функцию над каждым элементом 
			.catch(error=>console.error("load error"));	
	}
	$.event(1,document,"DOMContentLoaded",run);
})();

let help ="Для создания записи, открываем сайт без передаваемых аргументов, нажимаем по белому фону в левом верхнем углу. Вводим пароль и текст, далее получаем ссылку на созданную запись. Для получения текста записи, переходим по ранее полученной ссылке, после введения пароля, полученный зашифрованный текст будет расшифрован."
